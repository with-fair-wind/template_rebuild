// 我需要写一个函数模板 add，想要要求传入的对象必须是支持 operator+ 的，应该怎么写？
template <typename T>
auto add(const T &t1, const T &t2) -> decltype(t1 + t2) {
    std::puts("SFINAE+");
    return t1 + t2;
}

struct X {};

// 这样有啥好处吗？使用了 SFINAE 看起来还变复杂了。我就算不用这写法，如果对象没有 operator+ 不是一样会编译错误吗？
// 虽然前面说了 SFINAE 可以影响重载决议，我知道这个很有用，但是我这个函数根本没有别的重载，这样写还是有必要的吗？

// 如果就是简单写一个 add 函数模板不使用 SFINAE，那么编译器在编译的时候，会尝试模板实例化，生成函数定义，发现你这类型根本没有 operator+，于是实例化模板错误。
// 如果按照我们上面的写法使用 SFINAE，根据“代换失败不是错误”的规则，从重载集中丢弃这个特化 add，然而又没有其他的 add 重载，所以这里的错误是“未找到匹配的重载函数”。

// 这里的重点是什么？是模板实例化，能不要实例化就不要实例化！！！
// 如果我们使用 SFINAE，编译器就是直接告诉我：“未找到匹配的重载函数”，我们自然知道就是传入的参数没有满足要求。而且实例化模板也是有开销的，很多时候甚至很大。

int main() {
    add(1, 2);
    // add(X{}, X{});
}